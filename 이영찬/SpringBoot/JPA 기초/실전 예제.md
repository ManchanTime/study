# 조건

![image](https://github.com/ManchanTime/TrashBoys/assets/127479677/999e7c99-3a66-4cfe-a8ba-ddad85229da0)

### 도메인 모델

![image](https://github.com/ManchanTime/TrashBoys/assets/127479677/5ae87887-0621-4cee-b9fc-70959f2b0983)


### 테이블 설계

![image](https://github.com/ManchanTime/TrashBoys/assets/127479677/d57c436b-65e8-4def-90ba-9ff4e6a7a4ca)


### 엔티티 설계와 매핑

![image](https://github.com/ManchanTime/TrashBoys/assets/127479677/12d58501-88f7-4fc2-a495-695ee5ee75c1)

### 1 단계
+ 필요 객체 생성(Domain)
  Member, Order, OrderItem, Item

  getter, setter 생략
  + Member
    
    ![image](https://github.com/ManchanTime/TrashBoys/assets/127479677/37baae96-8779-4482-abc7-5f9b4d5bbdf9)

  + Order

    ![image](https://github.com/ManchanTime/TrashBoys/assets/127479677/80b1e3c5-d789-4a0a-9c45-7f87e113d7fe)

  + OrderItem
 
    ![image](https://github.com/ManchanTime/TrashBoys/assets/127479677/59920be3-7954-49c7-96c2-bd35d5ba2794)


  + Item
 
    ![image](https://github.com/ManchanTime/TrashBoys/assets/127479677/d2bd6ba1-b02a-4e46-8748-85ef3c6d656a)

  => 이 때 엔티티 설계 방식대로 단순 작성 시 문제 발생
  객체 설계를 테이블 설계에 맞춘 방식으로 객체지향의 장점을 이용할 수 없다.
  외례키를 객체에서 그대로 가져와서 사용하기 때문에 모든 SQL에 대해서 DB에 매번 접근해야한다.
  객체 그래프를 탐색할 수 없다.
  참조가 없기 때문에 애초에 엔티티 설계자체도 잘못된 것이다.

  => 고쳐 보자!!
  
