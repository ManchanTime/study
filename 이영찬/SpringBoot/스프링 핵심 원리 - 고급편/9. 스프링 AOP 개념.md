# 스프링 AOP 개념

+ 소개 - 핵심 기능 & 부가 기능
  + 핵심 기능
    객체가 제공하는 고유 기능으로 OrderService와 같은 로직 기능
  + 부가 기능
    핵심 기능을 보조하기 위해 제공되는 기능으로 로그 추적, 트랜잭션 기능 등이 있다. 이러한 기능들은 단독으로 사용되지 않고 핵심 기능과 함께 사용된다.

    + 여러 곳에서 공통으로 사용되는 부가 기능(횡단 관심사)

      ![image](https://github.com/ManchanTime/study/assets/127479677/dc58d1e3-d319-4c45-ab9f-d7d47cef9bd9)

    + 문제점
      + 부가 기능을 적용할 때 아주 많은 반복이 필요(여러 핵심 기능에서 같은 부가 기능 필요 시)
      + 중복 코드 생성
      + 수정 시 많은 곳에서 직접 찾아서 수정해야함

### AOP - Aspect(에스펙트)

+ 핵심 기능과 부가 기능 분리
  + 어플리케이션을 보는 관점을 횡단 관심사 관점으로 두고 부가 기능을 추가한 AOP(Aspect-Oriented-Programming)
 
![image](https://github.com/ManchanTime/study/assets/127479677/dd25d879-8ef1-4bf3-8f12-250a34757bd5)

+ AspectJ 프레임워크
  + AOP의 대표적인 구현으로 스프링에서도 AOP를 지원하지만 대부분 이 AspectJ의 문법을 사용하고 AspectJ가 제공하는 기능의 일부만 제공
  + 자바 프로그래밍 언어에 대한 완벽한 관점 지향 확장
  + 횡단 관심사의 깔끔한 모듈화
    + 오류 검사 및 처리
    + 동기화
    + 성능 최적화(캐싱)
    + 모니터링 및 로깅
   
+ AOP 적용 방식
  + 컴파일 시점
    + 컴파일 타임 - 위빙

      ![image](https://github.com/ManchanTime/study/assets/127479677/462f90b7-18a8-4fd4-9d2b-68ff00244e74)

      .java 소스 코드를 컴파일러에서 .class로 만드는 시점에 부가 기능을 추가할 수 있다. 이 때 AspectJ가 제공하는 특별한 컴파일러를 사용해야 한다.
      부가 기능 코드가 핵심 기능이 있는 컴파일 코드에 직접 추가되고 이때 AspectJ 컴파일러가 적용 유무를 판단하고 적용한다.

      + 단점
        AspectJ가 제공하는 컴파일러가 필수고 사용하기 복잡하다.
    
  + 클래스 로딩 시점
    + 로드 타임 - 위빙

      ![image](https://github.com/ManchanTime/study/assets/127479677/54ac2ebb-caf6-469a-ad4e-edf40760b1e4)

      자바가 실행되고 JVM 내부 클래스 로더에 .class 파일을 보관한다. 이 때 중간에서 .class 파일을 조작한 다음 JVM에 저장하는 방식이다.
      많은 모니터링 툴들이 이 방식을 사용한다.

      + 단점
        자바를 실행할 때 특별한 옵션(java - javaagent)을 통해 클래스 로더 조작기를 지정해야하기 때문에 번거롭고 운영하기 어렵다.
        
  + 런타임 시점(프록시)
    + 런타임 - 위빙

      ![image](https://github.com/ManchanTime/study/assets/127479677/0909d96a-d3d7-4862-b90e-9e9fc850332d)

      이전에 사용했던 방식이다. 컴파일이 끝나고 클래스 또한 JVM에 다 저장된 후 실행된다. 따라서 자바 언어가 제공하는 범위 안에서 부가 기능을 적용해야 한다.
      스프링 컨테이너와 프록시, DI, 빈 포스트 프로세서 같은 개념들을 모두 이용해서 적용한다. 이는 프록시 방식의 AOP이다.
      물론 이전 방식들에 비해 몇 가지 제약사항이 있지만 특별한 옵션이나 컴파일러가 필요없어 스프링만 있다면 얼마든지 AOP를 적용할 수 있다.

+ 부가 기능 적용 방식 차이점
  + 컴파일 시점: 실제 대상 코드에 에스팩트를 통한 부가 기능 호출 코드가 포함된다. AspectJ를 직접 이용해야 한다.
  + 클래스 로딩 시점: 실제 대상 코드에 에스팩트를 통한 부가 기능 호출 코드가 포함된다. AspectJ를 직접 이용해야 한다.
  + 런타임 시점: 실제 대상 코드는 유지되고 프록시를 통해서 부가 기능이 적용된다. 때문에 항상 프록시를 사용해야한다.

+ AOP 적용 위치
  + 적용 가능 지점(조인 포인트): 생성자, 필드 값 접근, static 메서드 접근, 메서드 실행
  + AspectJ를 직접 이용하는 컴파일 시점 방식이나 클래스 로딩 방식은 실제로 코드를 조작하기 때문에 모든 지점에 다 가능하다.
  + 프록시 방식은 코드를 직접 조작하지 않고 프록시를 통해 적용하기 때문에 메서드 실행 시점에만 부가 기능 로직을 적용할 수 있다.
    + 메서드 오버라이딩 개념으로 static, 필드 등에는 접근할 수 없다.
  + 프록시 방식인 스프링 AOP는 스프링 컨테이너가 관리하는 스프링 빈에만 AOP를 적용할 수 있다.

+ 참고
  + 스프링은 AspectJ 문접을 차용하고 프록시 방식의 스프링 AOP를 적용하는 것으로 AspectJ를 직접 사용하지는 않는다.
  + AspectJ를 직접 적용하는 것이 기능은 더 많겠지만 공부 내용도 많고 자바 관련 설정도 복잡하기 때문에 비교적 간단하고 편리한 스프링 AOP를 사용한다.

+ AOP 용어 정리
  + 조인 포인트

    ![image](https://github.com/ManchanTime/study/assets/127479677/bf9d1903-a1d0-4a8c-8860-ff1b6d560de8)

    + 어드바이스가 적용될 수 있는 위치, 메서드 실행, 생성자 호출, 필드 값 접근, static 메서드 접근 같은 프로그램 실행 중 지점
    + 추상적인 개념으로 AOP를 적용할 수 있는 모든 지점
    + 스프링 AOP는 생성자, static, 필드 등 접근이 불가능하기 때문에 메서드 실행 지점으로 고정

  + 포인트컷
    + 조인 포인트 중에서 어드바이스가 적용될 위치를 판별하는 기능
    + 주로 AspectJ 표현식을 사용하여 지정
    + 프록시 기반인 스프링 AOP는 메서드 실행 지점만 지정 가능

  + 타겟
    + 어드바이스를 받는 객체, 포인트컷으로 결정

  + 어드바이스
    + 부가 기능 로직
    + 특정 조인 포인트에서 Aspect에 의해 취해지는 조치
    + Around, After, Before와 같은 다양한 종류의 어드바이스 존재

  + 에스팩트
    + 어드바이스 + 포인트컷을 모듈화한 것
    + @Aspect
    + 여러 어드바이스와 포인트컷이 존재 가능
    + 어드바이저도 에스팩트의 한 종류라고 볼 수 있음
    
  + 어드바이저
    + 하나의 어드바이스와 하나의 포인트컷으로 구성
    + 스프링 AOP에서만 사용되는 용어

  + 위빙
    + 포인트컷으로 결정된 타겟의 조인 포인트에 어드바이스를 적용하는 것
    + 핵심 기능 코드에 영향을 주지않고 부가 기능 적용
    + AOP 적용을 위해 에스팩트를 객체에 연결한 상태
      + 컴파일 타임
      + 로드 타임
      + 런 타임
     
  + AOP 프록시
    + AOP 기능을 구현하기 위해 생성한 프록시 객체로 스프링 기준으로 JDK 동적 프록시, Cglib 프록시
      
